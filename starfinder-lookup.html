<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Starfinder Statblocks</title>
    <link href="https://fonts.googleapis.com/css?family=Michroma|Open+Sans:400,400i,700,700i|Special+Elite" rel="stylesheet"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
    <link rel="stylesheet" type="text/css" href="assets/css/starfinder-adventure-path.css"/>
</head>
<body ng-app="sfBestiary" ng-controller="main as vm">
<div class="container-fluid">
    <form ng-submit="vm.search(vm.searchTerm)" class="form-horizontal">
        <div class="form-group">
            <div class="col-xs-12">
                <div class="input-group">
                    <input type="text" class="form-control" title="Search" placeholder="Monster name..."
                           ng-model="vm.searchTerm">
                    <span class="input-group-btn">
                        <button class="btn btn-default" type="submit">Search</button>
                    </span>
                </div>
            </div>
        </div>
        <div class="form-group">
            <div class="col-xs-12" ng-show="vm.nearResults.length >= 2">
                Did you mean:
                <span ng-repeat="statblock in vm.nearResults">
                    <button type="button" class="btn btn-default"
                            ng-click="vm.statblock = statblock">{{statblock._type}}: {{statblock.name}}</button>
                </span>
            </div>
        </div>
        <div class="form-group">
            <div class="col-xs-12">
                <div ng-bind-html="vm.generateStatBlock(vm.statblock)"></div>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12">
                <p class="text-muted">
                    Source: <span>{{vm.sources[vm.statblock._source].name}}</span>
                </p>
            </div>
        </div>
    </form>
    <div class="row" ng-if="vm.lastErr">
        <div class="col-xs-12">
            <pre>{{vm.lastErr}}</pre>
        </div>
    </div>
    <div class="row">
        <div class="col-xs-12">
            <p class="text-center text-muted small">&copy; 2017 Curtis Oakley</p>
        </div>
    </div>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.2/angular.min.js" type="application/javascript"></script>
<script src="assets/js/levenshtein.js" type="application/javascript"></script>
<script type="application/javascript">
    'use strict';
    angular.module('sfBestiary', ['co.levenshtein'])
        .factory('modifier', [function() {
            return function(input) {
                if (input === null) {
                    return '—';
                } else if (input < 0) {
                    return input;
                } else {
                    return '+' + input;
                }
            };
        }])
        .controller('main', ['$http', '$sce', 'levenshtein', 'modifier', function($http, $sce, levenshtein, modifier) {
            var vm = this;
            var sfData = [];
            vm.size = {
                'F': 'Fine',
                'D': 'Diminutive',
                'T': 'Tiny',
                'S': 'Small',
                'M': 'Medium',
                'L': 'Large',
                'H': 'Huge',
                'G': 'Gargantuan',
                'C': 'Colossal'
            };

            // Get the bestiary
            $http.get('source/starfinder-data.json')
                .then(function(response) {
                    sfData = response.data;
                    vm.xpByCr = sfData.xpByCR;

                    // Re-order the sources to be keyed by source
                    vm.sources = {};
                    angular.forEach(sfData.sources, function(source) {
                        vm.sources[source.source] = source;
                    });
                })
                .catch(function(err) {
                    vm.lastErr = err;
                });

            function findStatblock(name) {
                // The monster must have a levenshtein distance of less than seven from the name
                var shortestDistance = 8;

                var foundStatblocks = [];
                var statblocks = sfData.statblocks;
                var i, l, x, distance, statblockName;
                name = name.toLowerCase();

                // Go through all the monsters to find ones with a similar name
                for (i = 0, l = statblocks.length; i < l; i++) {
                    statblockName = statblocks[i].name.toLowerCase();
                    if (statblockName === name) {
                        // Exact match
                        return [statblocks[i]];
                    }
                    if (statblockName.indexOf(name) !== -1) {
                        // Name is a substring, place at the beginning
                        foundStatblocks.unshift(statblocks[i]);
                    } else {
                        // Find the monsters with the closest levenshtein distance to the name
                        distance = levenshtein(name, statblockName);
                        if (distance < shortestDistance) {
                            // Closer match found
                            shortestDistance = distance;

                            // Remove monsters that are further away from matching
                            for (x = foundStatblocks.length - 1; x >= 0; x--) {
                                if ('distance' in foundStatblocks[x]) {
                                    foundStatblocks.splice(x, 1);
                                } else {
                                    break;
                                }
                            }

                            // Place this monster into the array
                            foundStatblocks.push({'monster': statblocks[i], 'distance': distance});
                        } else if (distance == shortestDistance) {
                            foundStatblocks.push({'monster': statblocks[i], 'distance': distance});
                        }
                    }
                }

                // Fix monsters with distance
                for (x = foundStatblocks.length - 1; x >= 0; x--) {
                    if ('distance' in foundStatblocks[x]) {
                        foundStatblocks.splice(x, 1, foundStatblocks[x].monster);
                    } else {
                        break;
                    }
                }

                return foundStatblocks;
            }

            vm.search = function(name) {
                // Find monsters with similar names
                vm.nearResults = findStatblock(name);

                // Select the first monster
                vm.statblock = (vm.nearResults.length > 0) ? vm.nearResults[0] : null;
            };

            vm.generateStatBlock = function(statblock) {
                /*
                <div class="statblock" ng-class="{{vm.statblock._type}}" ng-show="vm.statblock">
                    <div class="name">
                        <h2>{{vm.statblock.name}} <span>CR {{vm.statblock.cr}}</span></h2>
                    </div>
                    <div class="stats">
                        <p><strong>XP {{vm.xpByCr[vm.statblock.cr]}}</strong></p>
                        <p ng-show="vm.statblock.tag">{{vm.statblock.tag}}</p>
                        <p ng-show="vm.statblock._type == 'creature'">{{vm.statblock.alignment}} {{vm.size[vm.statblock.size]}} {{vm.statblock.type}} <span ng-show="vm.statblock.typeTag">({{vm.statblock.typeTag}})</span></p>
                        <p ng-show="vm.statblock._type == 'creature'">
                            <strong>Init</strong> {{vm.statblock.init | modifier}};
                            <strong>Senses</strong> {{vm.statblock.senses}};
                            <strong>Perception</strong> {{vm.statblock.perception | modifier}}
                        </p>
                        <div ng-show="vm.statblock._type == 'creature'">
                            <h5>Defense <span><strong>HP</strong> {{vm.statblock.hp}}</span></h5>
                            <p><strong>EAC</strong> {{vm.statblock.eac}}; <strong>KAC</strong> {{vm.statblock.kac}}</p>
                            <p><strong>Fort</strong> {{vm.statblock.fort | modifier}}; <strong>Ref</strong> {{vm.statblock.ref | modifier}}; <strong>Will</strong> {{vm.statblock.will | modifier}}</p>
                        </div>
                    </div>
                </div>
                 */
                function tagIf(attr, tag, prepend) {
                    if (statblock[attr]) {
                        return '<' + tag + '>' + prepend + statblock[attr] + '</' + tag + '>';
                    } else {
                        return '';
                    }
                }
                function tagIfIn(attr, obj, tag, prepend) {
                    if (statblock[attr] && statblock[attr] in obj) {
                        return '<' + tag + '>' + prepend + obj[statblock[attr]] + '</' + tag + '>';
                    } else {
                        return '';
                    }
                }
                function safeLabel(label, attr, isModifier) {
                    var response = '',
                        i, l = label.length;

                    // Convert attr and isModifier to arrays if needed //
                    // Take the lowercase version of the labels and use that as the attributes if we don't have any attributes
                    if (!angular.isArray(attr)) {
                        var newAttr = [];
                        for (i = 0; i < l; i++) {
                            newAttr[i] = label[i].toLowerCase();
                        }
                        attr = newAttr;
                    }
                    // If the isModifier isn't an array, create an array filled with the passed in isModifier
                    if (!angular.isArray(isModifier)) {
                        var newIsModifier = [];
                        for (i = 0; i < l; i++) {
                            newIsModifier[i] = isModifier;
                        }
                        isModifier = newIsModifier;
                    }

                    // Take all the attributes and labels and make a semi-colon separated list of them
                    var list = [];
                    for (i = 0; i < l; i++) {
                        if (attr[i] in statblock) {
                            list.push('<strong>' + label[i] + '</strong> ' + (isModifier[i] ? modifier(statblock[attr[i]]) : statblock[attr[i]]));
                        }
                    }
                    if (list.length > 0) {
                        response = '<p>' + list.join('; ') + '</p>';
                    }

                    return response;
                }
                function safeJoin(label, attr, separator) {
                    attr = (attr ? attr : label.toLowerCase());
                    separator = separator || ', ';

                    var response = '';
                    if (statblock[attr]) {
                        response = '<p><strong>' + label + '</strong> ' + joinIfArray(statblock[attr], separator) + '</p>';
                    }
                    return response;
                }
                function joinIfArray(arr, separator) {
                    if (angular.isArray(arr)) {
                        return arr.join(separator);
                    } else {
                        return arr;
                    }
                }
                function properCase(str) {
                    return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
                }

                var html = '';
                if (statblock && '_type' in statblock) {
                    // Build the basic header
                    html =
                        '<div class="statblock row ' + statblock._type + '"><div class="col-xs-12 col-md-8 col-lg-4">' +
                            '<div class="name">' +
                                '<h2>' + statblock.name + tagIf('cr', 'span', 'CR ') + '</h2>' +
                            '</div>' +
                            '<div class="stats">' +
                                tagIfIn('cr', vm.xpByCr, 'p', '<strong>XP</strong> ') +
                                tagIf('tag', 'p', '');

                    // Build the statblock for the given type
                    if (statblock._type === 'creature') {
                        var hasGrab = false,
                            hasSwarmAttack = false,
                            lower;

                        var formatAttack = function(attack) {
                            if (!hasGrab && attack.damage.toLowerCase().indexOf('grab') >= 0) {
                                hasGrab = true;
                            }
                            var bonus = ' ';
                            if (attack.bonus) {
                                bonus += attack.bonus;
                            } else if (!hasSwarmAttack && attack.name.toLowerCase().indexOf("swarm attack") >= 0) {
                                hasSwarmAttack = true;
                            }
                            return attack.name + bonus + ' (' + attack.damage + ')';
                        };

                        // Add the basic information (alignment, initiative, etc)
                        html += '<p>';
                        if (statblock.alignment) {
                            html += statblock.alignment + ' ';
                        }
                        if (statblock.size) {
                            if (statblock.size in vm.size) {
                                html += vm.size[statblock.size] + ' '
                            } else {
                                html += statblock.size + ' ';
                            }
                        }
                        if (statblock.type) {
                            html += statblock.type + ' ';
                        }
                        if (statblock.typeTag) {
                            html += '(' + statblock.typeTag + ')';
                        }
                        html += '</p>';

                        html += safeLabel(['Init', 'Senses', 'Perception'], null, [true, false, true])
                              + safeLabel(['Aura']);

                        // Add the Defense section
                        html += '<div><h5>Defense ' + tagIf('rp', 'span', '<strong style="padding-left:15px">RP</strong> ') + tagIf('hp', 'span', '<strong>HP</strong> ') + '</h5>' +
                                safeLabel(['EAC', 'KAC']) +
                                safeLabel(['Fort', 'Ref', 'Will', ''], ['fort', 'ref', 'will', 'save'], [true, true, true, false]) +
                                safeLabel(['Defensive Abilities', 'DR', 'SR', 'Immunities', 'Resistances'], ['defensiveAbilities', 'dr', 'sr', 'immunities', 'resistances']) +
                                safeLabel(['Weaknesses']) +
                            '</div>';

                        // Add the Offense section
                        html += '<div><h5>Offense</h5>' +
                                safeLabel(['Speed']);

                        // Build the list of attacks grouped by type
                        var offense = {};
                        angular.forEach(statblock.attacks, function(attack) {
                            if (!offense[attack.type]) {
                                offense[attack.type] = [];
                            }
                            offense[attack.type].push(formatAttack(attack));
                        });
                        angular.forEach(offense, function(attacks, type) {
                            html += '<p><strong>' + properCase(type) + '</strong> ' + attacks.join(' or ') + '</p>';
                        });
                        if ('multiAttack' in statblock && Array.isArray(statblock.multiAttack) && statblock.multiAttack.length > 0) {
                            html += '<p><strong>Multiattack</strong> ';
                            angular.forEach(statblock.multiAttack, function(attack, i) {
                                html += formatAttack(attack);
                                if (i < statblock.multiAttack.length - 1) {
                                    // Multiattacks are joined with commas
                                    html += ', ';
                                }
                            });
                            html += '</p>';
                        }
                        html += safeLabel(['Special Attacks'], ['specialAttacks']);

                        html += safeLabel(['Space', 'Reach'])
                              + safeLabel(['Offensive Abilities'], ['offensiveAbilities']);
                        // TODO handle spellBlocks and spellExtra
                        if (statblock.spellClass || statblock.spellAbility || statblock.spells) {
                            // Add spells
                            html += '<p><strong>';
                            if (statblock.spellClass) {
                                html += statblock.spellClass + ' spells known</strong>';
                            } else if (statblock.spellAbility) {
                                html += statblock.spellAbility + ' Spell-Like Abilities</strong>';
                            } else {
                                html += 'Spell-Like Abilities</strong>'
                            }
                            if (statblock.spellCL) {
                                html += ' (' + statblock.spellCL + ')';
                            }
                            html += '</p>';
                            if (statblock.spells) {
                                html += '<ul class="ability-list"><li>' + joinIfArray(statblock.spells, '</li><li>') + '</li></ul>'
                            }
                        }

                        html += '</div>';

                        // Add the statistics section
                        html += '<div><h5>Statistics</h5>' +
                            safeLabel(['Str', 'Dex', 'Con', 'Int', 'Wis', 'Cha'], null, true);

                        if (statblock.skills) {
                            var list = [];
                            angular.forEach(statblock.skills, function(bonus, skill) {
                                list.push(skill + ' ' + modifier(bonus));
                            });
                            html += '<p><strong>Skills</strong> ' + list.join(', ') + '</p>';
                        }
                        if (statblock.feat) {
                            html += '<p><strong>Feat</strong> ' + joinIfArray(statblock.feat, ', ') + '</p>';
                        }
                        html +=
                            safeJoin('Languages') +
                            safeLabel(['Other Abilities'], ['abilities']) +
                            safeJoin('Gear');
                        html += '</div>';

                        // Add the ecology section
                        if (statblock.environment || statblock.organization) {
                            html += '<div><h5>Ecology</h5>' +
                                safeLabel(['Environment']) +
                                safeJoin('Organization') + '</div>';
                        }

                        // Add the special abilities section (if applicable)
                        if (statblock.specialAbilities) {
                            html += '<div><h5>Special Abilities</h5>';
                            angular.forEach(statblock.specialAbilities, function(ability) {
                                html += '<p><strong>' + ability.name + ' (' + properCase(ability.type) + ')</strong> ' +
                                    joinIfArray(ability.text, '</p><p>') + '</p>';
                            });
                            html += '</div>';
                        }

                        html += '</div>';

                        // Add the description
                        if (statblock.description) {
                            html += '<div class="description"><p>';
                            if (angular.isArray(statblock.description)) {
                                html += statblock.description.join('</p><p>');
                            } else {
                                html += statblock.description;
                            }
                            html += '</p></div>';
                        }

                        html += '</div>';
                        if ('role' in statblock) {
                            html += '<div class="col-xs-1">' +
                                '<img class="role img-responsive" alt="' + statblock.role + '" title="' + statblock.role + '" src="assets/images/starfinder/' + statblock.role + '_symbol.png"/>' +
                                '</div>';
                        }

                        // Add helpers for special abilities and traits
                        html += '<div class="rule-help col-xs-12 col-md-4">';
                        if ('defensiveAbilities' in statblock) {
                            lower = statblock.defensiveAbilities.toLowerCase();
                            if (lower.indexOf('amorphous') >= 0) {
                                html += '<h4>Amorphous (Ex)</h4>' +
                                    '<p>The creature’s body is malleable and shapeless. It does not take double damage from critical hits, but it is affected by critical hit effects normally.</p>';
                            }
                            if (lower.indexOf('evasion') >= 0) {
                                html += '<h4>Evasion (Ex)</h4>' +
                                    '<p>If the creature succeeds at a Reflex save against an effect that normally has a partial effect on a successful save, it instead suffers no effect. This ability is lost if the creature is helpless or otherwise unable to move.</p>';
                            }
                            if (lower.indexOf('fast healing') >= 0) {
                                html += '<h4>Fast Healing (Ex)</h4>' +
                                    '<p>The creature regains the listed number of Hit Points at the start of its turn. Unless otherwise noted, the creature can never exceed its maximum Hit Points.</p>' +
                                    '<p>Fast healing does not restore Hit Points lost from starvation, thirst, or suffocation, nor does it allow a creature to regrow or reattach lost body parts, unless otherwise stated. Fast healing continues to function until a creature dies, at which point the effects of fast healing end immediately.</p>';
                            }
                            if (lower.indexOf('swarm defenses') >= 0) {
                                html += '<h4>Swarm Defenses (Ex)</h4>' +
                                    '<p>Swarms take damage from weapons differently depending on how the weapon targets them.</p>' +
                                    '<p>A swarm is immune to attacks and effects that target a single creature (including single-target spells), with the exception of mind-affecting effects if the swarm has an Intelligence score and an ability similar to a formian’s hive mind.</p>' +
                                    '<p>A swarm takes half again as much damage (+50%) from effects that affect all targets in an area, such as grenades, blast and explode weapons, and many evocation spells.</p>' +
                                    '<p>A swarm takes normal damage from an attack or effect that affects multiple targets (including lines and fully automatic mode attacks). For the purpose of automatic fire, the swarm counts as five targets. For example, if an automatic attack is made using 12 rounds of ammunition, it can attack a maximum of six targets, so it can damage a swarm normally. However, if two other targets are closer to the attacker than the swarm, they must be attacked first, leaving only four attacks to target the swarm, so it takes no damage.</p>';
                            }
                            if (lower.indexOf('uncanny agility') >= 0) {
                                html += '<h4>Uncanny Agility (Ex)</h4>' +
                                    "<p>The creature is immune to the flat-footed condition, and its opponents don't gain any bonuses to attack rolls against it from flanking it or attacking it when it's prone. Furthermore, covering fire and harrying fire don't provide any advantage against it.</p>";
                            }
                            if (lower.indexOf('unflankable') >= 0) {
                                html += '<h4>Unflankable (Ex)</h4>' +
                                    "<p>Flanking the creature does not grant any bonuses, and abilities that function only against a creature that is flanked do not function against it.</p>";
                            }
                        }
                        if ('offensiveAbilities' in statblock) {
                            lower = statblock.offensiveAbilities.toLowerCase();
                            if (lower.indexOf('gaze') >= 0) {
                                html += '<h4>Gaze (Su)</h4>' +
                                    '<p>Opponents that look at a creature with a gaze ability are in danger of being charmed, being paralyzed, being turned to stone, or suffering another negative effect. Each opponent within the gaze’s listed range must attempt a saving throw (usually Fortitude or Will) at the beginning of its turn. On a successful save, the effect is negated. An opponent can give itself an advantage against this ability in one of two ways.</p>' +
                                    '<p><i>Looking Obliquely:</i> An opponent that avoids looking directly at the creature’s face (either by following the creature’s shadow or by tracking it in a reflective surface) or that looks at the creature through a camera or heads-up display gains a +4 circumstance bonus to the saving throw. However, the creature with the gaze ability gains concealment against that opponent.</p>' +
                                    '<p><i>Blocking Its Vision:</i> By completely blocking or covering its own visual sensors, an opponent doesn’t need to attempt a save against the gaze. However, the creature with the gaze ability gains total concealment against that opponent. Gaze abilities can affect ethereal opponents but not opponents without visual sensors. A creature is immune to the gaze abilities of others of its kind unless otherwise noted. Allies of a creature with a gaze ability can still be affected, but they are always considered to be looking obliquely at the creature.The creature can also veil its eyes, thus negating its gaze ability.</p>';
                            }
                            if (lower.indexOf('whirlwind') >= 0) {
                                html += '<h4>Whirlwind (Ex)</h4>' +
                                    "<p>The creature can transform into a whirlwind. Unless otherwise specified, the creature can remain in whirlwind form for a number of rounds equal to half its CR. If the creature has a fly speed, it retains that in its whirlwind form. If it does not have a fly speed, it gains an extraordinary fly speed (with average maneuverability) equal to its base speed. A creature in whirlwind form can move freely into and through other creatures’ spaces, and it does not provoke attacks of opportunity as a result of its movement.</p>" +
                                    "<p>The base of a creature in whirlwind form occupies a 5-foot square, and the whirlwind is twice as wide at its top as its base and has a height equal to four times the width of its base; this doesn’t change the size category of the creature. If a creature is Large or larger, it can vary the size of its whirlwind form up to a maximum of a base equal to its normal space as a swift or move action. A creature in whirlwind form does not threaten any spaces around it, and it cannot make its normal attacks.</p>" +
                                    "<p>If a creature in whirlwind form enters the space of another creature, that creature must succeed at a Fortitude save with the listed DC or take the whirlwind’s listed damage. If the whirlwind covers all of the creature’s space, the creature must also succeed at a Reflex save or be picked up by the whirlwind and carried along with it. A carried creature is flatfooted, grappled, and off-target, and it automatically takes the whirlwind’s damage at the beginning of its turn. If the carried creature can fly, it can attempt a Reflex save as a move action, escaping on a successful save. If a carried creature does not escape, it can attempt a Fortitude save; if it succeeds, it can take any remaining actions it has on its turn (other than movement). On a failed save, the carried creature is unable to act until its next turn or until the whirlwind releases it.</p>" +
                                    "<p>A creature in whirlwind form can carry up to two creatures of its size, with the total number it can carry doubling for every size category the affected creatures are smaller than the whirlwind. The creature in whirlwind form can eject a carried creature at any time during its turn, dropping the carried creature in a space of its choice adjacent to its position at the time of ejection. At the GM’s discretion, if the whirlwind is in contact with dirt, gases, water, or other material that can be easily drawn into it, the whirlwind blocks all vision within it (including darkvision) and blocks line of sight through it.</p>";
                            }
                        }
                        if (hasGrab) {
                            html += '<h4>Grab (Ex)</h4>' +
                                '<p>If the creature hits with the indicated attack (usually a claw or bite attack), it deals the normal damage. If the creature’s attack roll successfully hits the target’s KAC + 4, the creature also automatically grapples the foe as a free action. (If it hits the target’s KAC + 13, it instead pins the target.) The creature does not need to have a spare limb free to perform this grapple, as long as it can make the listed attack, and it can potentially grapple more than one target if it has more than one attack with the grab ability. The creature can maintain the grab either with another successful grab attack or by performing the grapple combat maneuver normally.';
                        }
                        if (hasSwarmAttack) {
                            html += '<h4>Swarm Attack (Ex)</h4>' +
                                '<p>The creature automatically deals the listed damage to each creature whose space it occupies at the end of its turn, with no attack roll needed. Swarm attacks are not subject to a miss chance for concealment or cover.</p>';
                        }
                        if ('immunities' in statblock) {
                            lower = statblock.immunities.toLowerCase();
                            if (lower.indexOf('construct immunities') >= 0) {
                                html += '<h4>Construct Immunities (Ex)</h4>' +
                                    '<p>Constructs are immune to the following effects, unless the effect specifies that it works against constructs.<ul>' +
                                    '<li>Bleed, death effects, disease, mind-affecting effects, necromancy effects, paralysis, poison, sleep, and stunning.</li>' +
                                    '<li>Ability damage, ability drain, energy drain, exhaustion, fatigue, negative levels, and nonlethal damage.</li>' +
                                    '<li>Any effect that requires a Fortitude save (unless the effect works on objects or is harmless).</li></ul></p>';
                            }
                            if (lower.indexOf('elemental immunities') >= 0) {
                                html += '<h4>Elemental Immunities (Ex)</h4>' +
                                    '<p>Elementals are immune to the following effects, unless the effect specifies that it works against elemental creatures:<ul>' +
                                    '<li>Bleed, critical hits, paralysis, poison, sleep effects, and stunning.</li>' +
                                    '<li>Flanking—elementals are unflankable.</li></ul></p>';
                            }
                            if (lower.indexOf('plant immunities') >= 0) {
                                html += '<h4>Plant Immunities (Ex)</h4>' +
                                    '<p>Plants are immune to the following effects, unless the effect specifies it works against plants.<ul>' +
                                    '<li>Mind-affecting effects, paralysis, poison, polymorph, sleep, and stunning.</li></ul></p>';
                            }
                            if (lower.indexOf('swarm immunities') >= 0) {
                                html += '<h4>Swarm Immunities (Ex)</h4>' +
                                    '<p>Swarms are immune to the following effects, unless the effect specifies it works against swarms.<ul>' +
                                    '<li>Bleeding, critical hits, flat-footed, off-target, pinned, prone, staggered, and stunned.</li>' +
                                    '<li>Combat maneuvers—swarms can’t be affected by and can’t perform combat maneuvers, unless the swarm’s description says otherwise.</li>' +
                                    '<li>Flanking—swarms are unflankable.</li>' +
                                    '<li>Dying—a swarm reduced to 0 Hit Points breaks up and ceases to exist as a swarm, though individual members of it might survive.</li></ul></p>';
                            }
                            if (lower.indexOf('undead immunities') >= 0) {
                                html += '<h4>Undead Immunities (Ex)</h4>' +
                                    '<p>Undead are immune to the following effects, unless the effect specifies it works against undead creatures.<ul>' +
                                    '<li>Bleed, death effects, disease, mind-affecting effects, paralysis, poison, sleep, and stunning.</li>' +
                                    '<li>Ability damage, ability drain, energy drain, exhaustion, fatigue, negative levels, and nonlethal damage.</li>' +
                                    '<li>Any effect that requires a Fortitude save (unless the effect works on objects or is harmless).</li></ul></p>';
                            }
                        }
                        if ('abilities' in statblock) {
                            lower = statblock.abilities.toLowerCase();
                            if (lower.indexOf('earth glide') >= 0) {
                                html += '<h4>Earth Glide (Ex)</h4>' +
                                    '<p>When the creature burrows, it can pass through dirt, stone, or almost any other sort of earth except metal as easily as a fish swims through water. If protected against fire damage, it can even glide through lava. Its burrowing leaves behind no tunnel or hole, nor does it create any ripple or other sign of its presence.</p>';
                            }
                            if (lower.indexOf('mindless') >= 0) {
                                html += '<h4>Mindless (Ex)</h4>' +
                                    '<p>The creature has no Intelligence score or modifier and is immune to mind-affecting effects. Any DCs or other statistics that rely on an Intelligence score treat the creature as having a score of 10 (+0).</p>';
                            }
                            if (lower.indexOf('unliving') >= 0) {
                                html += '<h4>Unliving (Ex)</h4>' +
                                    '<p>The creature has no Constitution score or modifier. Any DCs or other statistics that rely on a Constitution score treat the creature as having a score of 10 (+0). The creature is immediately destroyed when it reaches 0 Hit Points. An unliving creature doesn’t heal damage naturally, but a construct can be repaired with the right tools. Spells such as make whole can heal constructs, and magic effects can heal undead. An unliving creature with fast healing (see Alien Archive page 154) still benefits from that ability. Unliving creatures don’t breathe, eat, or sleep. They can’t be raised or resurrected, except through the use of miracle, wish, or a similar effect that specifically works on unliving creatures.</p>';
                            }
                        }
                        if ('feat' in statblock) {
                            lower = statblock.feat.toLowerCase();
                            if (lower.indexOf('cleave') >= 0) {
                                html += '<h4>Cleave (Combat)</h4>' +
                                    '<p>You can strike two adjacent foes with a single swing.</p>' +
                                    '<p><strong>Benefit:</strong> As a standard action, you can make a single melee attack against a foe within reach. If you hit, you deal damage ' +
                                    'normally and can make an additional melee attack (using your full base attack bonus) against a foe that is adjacent to the ' +
                                    'first and also within reach. You can make only one additional attack per round with this feat. When you use this feat, you ' +
                                    'take a -2 penalty to your Armor Class until your next turn.</p>';
                            }
                            if (lower.indexOf('mobility') >= 0) {
                                html += '<h4>Mobility (Combat)</h4>' +
                                    '<p>You can easily move past dangerous foes.</p>' +
                                    '<p><strong>Benefit:</strong> You gain a +4 bonus to your Armor Class against attacks of opportunity that you provoke by leaving a threatened square.</p>';
                            }
                            if (lower.indexOf("spring attack") >= 0) {
                                html += '<h4>Spring Attack (Combat)</h4>' +
                                    '<p>You can deftly move up to a foe, strike, and withdraw before it can react.</p>' +
                                    '<p><strong>Benefit:</strong> As a full action, you can move up to your speed and make a single melee attack or combat maneuver without provoking any ' +
                                    'attacks of opportunity from the target of your attack. You can move both before and after the attack, but you must move at least 10 feet before the attack, ' +
                                    'and the total distance that you move cannot be greater than your speed. You cannot use this ability to attack a foe that is adjacent to you at the start of your turn. ' +
                                    'If you have the trick attack class feature, you can take your movement from trick attack at any time during a trick attack with a melee weapon (instead of only before), ' +
                                    'without provoking any attacks of opportunity from the target of your attack.</p>';
                            }
                        }
                        var contains = function(haystack, needle) {
                            if (Array.isArray(haystack)) {
                                for (var i = 0, l = haystack.length; i < l; i++) {
                                    if (haystack[i].toLowerCase().indexOf(needle) >= 0) {
                                        return true;
                                    }
                                }
                                return false;
                            }
                            return haystack.toLowerCase().indexOf(needle) >= 0;
                        };
                        if (('specialAttacks' in statblock && contains(statblock.specialAttacks, 'distraction')) || ('offensiveAbilities' in statblock && statblock.offensiveAbilities.toLowerCase().indexOf('distraction') >= 0)) {
                            html += '<h4>Distraction (Ex)</h4>' +
                                '<p>The creature can nauseate targets that it damages. A living creature that takes damage from a creature with the distraction ability is nauseated for 1 round; the target can negate the effect with a successful Fortitude save at the listed DC.</p>';
                        }
                        html += '</div>';

                        // TODO variant description block
                    } else if (statblock._type === 'trap') {
                        // Add trap stats
                        html += safeLabel(['Type', 'Perception', 'Disable']) +
                                safeLabel(['Trigger', 'Reset']) +
                                safeLabel(['Effect']) + '</div>'; // TODO multiple effect traps (or enable MarkDown)
                    } else if (statblock._type === 'affliction') {
                        // Add affliction stats
                        html += safeLabel(['Type', 'Save']) +
                                safeLabel(['Track', 'Frequency']) +
                                safeLabel(['Effect']) +
                                safeLabel(['Cure']) + '</div>';
                    } else if (statblock._type === 'starship') {
                        // TODO starship statblock
                        html += '</div>';
                    }
                    html += '</div>';
                }

                // map[area]map[key]hint
                // var hints = {
                //     'abilities': {
                //         'mindless': {
                //             title: 'Mindless',
                //             type: 'ex',
                //             text: 'The creature has no Intelligence score or modifier and is immune to mind-affecting effects. Any DCs or other statistics that rely on an Intelligence score treat the creature as having a score of 10 (+0).'
                //         }
                //     }
                // };

                /*

 */

                return $sce.trustAsHtml(html);
            }
        }]);
</script>
</body>
</html>